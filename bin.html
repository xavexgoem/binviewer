<!-- TODO

* RGB materials aren't handled
* Probably refactor the UI stuff out of setupThree

-->

<!DOCTYPE html>
<head>
<title>LGMD BIN viewer</title>
<script type="importmap">
	{
		"imports": {
			"three": "https://unpkg.com/three/build/three.module.js",
      "three/addons/": "https://unpkg.com/three/examples/jsm/"
		}
	}
</script>

<style>
	* { 
		font-family: monospace; 
		font-weight: bold; 
		color: #111; 
	}
	.main-flex { 
		display: flex; 
		flex-direction: row; 
		align-items: flex-start; 
		justify-content: space-between;
	}
	.contain { 
		width: 33%; 
		min-width: 340px; 
		max-width: 33%;
	}
	table { 
		width: 100%; 
		min-width: 340px; 
		border-collapse: collapse; 
	}
	th { 
		background-color: #444; 
		color: #fff; 
		font-size: 110%; 
	}
	td { 
		margin: 0; 
		padding: 0; 
	}
	tr:nth-child(odd) { 
		background-color: #eee; 
	}
	.sep { 
		border-bottom: 2px solid #999;
	}
	.viewer { 
		display: flex;
		flex-direction: column;
		flex-grow: 1;
		min-width: 340px;
		align-items: stretch;
	}

	#viewer {
		flex-grow: 2;
		min-height: 480px; 
		display: flex;
		justify-content: center;
		align-items: center;
	}
	#viewer-control { 
		text-align: center; 
		width: 33%;
	}
</style>
</head>
<body>
<div>
	<label for="binInput">Select .bin file:</label>
	<input type="file" id="input" accept=".bin">
	<label for="textureInput">Select texture images (pcx not supported):</label>
	<input type="file" id="textureInput" multiple accept="image/*">
	<label for="textureDirectoryInput">Or upload entire texture directory:</label>
	<input type="file" id="textureDirectoryInput" webkitdirectory directory multiple accept="image/*">
</div>

<div class="main-flex">
	<div class="contain">
		<table id="table">
		</table>
	</div>
	<div class="viewer">
		<div style="text-align:center; margin-top:8px;" id="viewer"></div>
		<div id="viewer-control" style="text-align: left;">
			<label><input type="checkbox" id="toggle-bbox" checked> Show bounding box</label><br>
			<label><input type="checkbox" id="toggle-vhots" checked> Show vhots</label>
		</div>
	</div>
</div>
</div>

<script type="module">



function stat(id, val, type="") {
	let $elem = document.getElementById(id);
	if(type == "vec3") {
		let x = Number.parseFloat(val[0]).toFixed(2);
		let y = Number.parseFloat(val[1]).toFixed(2);
		let z = Number.parseFloat(val[2]).toFixed(2);
		$elem.innerHTML = x + ", " + y + ", " + z;
    } else if(type == "hex") {
        $elem.innerHTML = "0x" + val.toString(16).toUpperCase();
	} else {
		$elem.innerHTML = val;
	}
}

///////// THREEJS STUFF ///////////
import * as THREE from 'three';
import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

const AppState = {
	model: null,
	selectedTextures: {},
	threeScene: null,
	threeCamera: null,
	threeRenderer: null,
	threeMesh: null,
	boundingBox: null,
	materials: [],
	vhotMarkers: []
};

function initializeApp() {
	document.getElementById('input').addEventListener('change', handleFileInput);
	document.getElementById('textureInput').addEventListener('change', handleTextureInput);
	document.getElementById('textureDirectoryInput').addEventListener('change', handleDirectoryInput);
	
	// Add resize listener so canvas can respond
	window.addEventListener('resize', handleResize);
}

function handleResize() {
	if (AppState.threeRenderer && AppState.threeCamera) {
		const viewer = document.getElementById("viewer");
		const width = viewer.clientWidth;
		const height = viewer.clientHeight;
		
		AppState.threeCamera.aspect = width / height;
		AppState.threeCamera.updateProjectionMatrix();
		AppState.threeRenderer.setSize(width, height);
	}
}

function handleFileInput(e) {
	const file = e.target.files[0];
	if (file) {
		const reader = new FileReader();
		reader.onload = (event) => {
			AppState.model = read_bin(event.target.result);
		};
		reader.readAsArrayBuffer(file);
	}
}

function handleTextureInput(e) {
	loadTextures(e.target.files);
}

function handleDirectoryInput(e) {
	loadTextures(e.target.files);
}

function loadTextures(files) {
	AppState.selectedTextures = {};
	for (let file of files) {
		// Store with original filename for reference
		AppState.selectedTextures[file.name] = file;
	}
	
	// Re-render with new textures if model is loaded
	if (AppState.model) {
		let geometries = toThree(AppState.model);
		setupThree(geometries);
	}
}

function findTextureFile(textureName) {
	if (!textureName) return null;
	
	// Because ND does not depend on extension, we don't care about it either
	// But because OD _does_, we may care later. 
	const nameWithoutExt = textureName.split('.')[0].toLowerCase();
	for (let [filename, file] of Object.entries(AppState.selectedTextures)) {
		const fileWithoutExt = filename.split('.')[0].toLowerCase();
		if (fileWithoutExt === nameWithoutExt) {
			return file;
		}
	}
	
	return null;
}

function setupThree(geometries) {
	if (AppState.threeRenderer && AppState.threeRenderer.domElement.parentNode) {
		AppState.threeRenderer.domElement.parentNode.removeChild(AppState.threeRenderer.domElement);
	}

	AppState.threeScene = new THREE.Scene();
	AppState.threeScene.background = new THREE.Color(0xf0f0f0);

	let viewer = document.getElementById("viewer");
	let width = viewer.clientWidth;
	let height = viewer.clientHeight;
	AppState.threeCamera = new THREE.PerspectiveCamera(45, width / height, 0.1, 1000);
	AppState.threeCamera.position.set(0, 5, 12);
	AppState.threeCamera.lookAt(0, 0, 0);

	// Try to load textures for each material
	AppState.materials = [];
	if (AppState.model && AppState.model.materials) {
		for (let mat of AppState.model.materials) {
			let texName = mat.name.trim();
			let texture = null;
			let textureFile = findTextureFile(texName);
			
			if (textureFile) {
				let url = URL.createObjectURL(textureFile);
				texture = new THREE.TextureLoader().load(url, function() {
					console.log(`Texture loaded from file: ${textureFile.name} for material: ${texName}`);
				});
				texture.flipY = true;
			}
			
			let threeMat;
			if (texture) {
				texture.wrapS = THREE.RepeatWrapping;
				texture.wrapT = THREE.RepeatWrapping;
				threeMat = new THREE.MeshLambertMaterial({ map: texture, flatShading: false });
			} else {
				threeMat = new THREE.MeshLambertMaterial({ color: 0x6699cc, flatShading: false });
			}
			AppState.materials.push(threeMat);
		}
	}
	// Scene graph, since there are so many children that need to be transformed
	const sceneRoot = new THREE.Group();
	sceneRoot.rotation.x = -(Math.PI / 2);
	sceneRoot.rotation.z = (Math.PI / 2);
	AppState.threeScene.add(sceneRoot);

	// For each subobject, create a group with its local transform.
	// Then build the hierarchy from child/sibling pointers
	if (AppState.model && Array.isArray(AppState.model.objects)) {
		const objects = AppState.model.objects;
		const subGroups = new Array(objects.length);
		const parentIndex = new Array(objects.length).fill(-1);

		// Create groups and apply local transforms
		for (let i = 0; i < objects.length; i++) {
			const sub = objects[i];
			const g = new THREE.Group();
			if (sub.sub_transform_matrix) {
				g.applyMatrix4(sub.sub_transform_matrix);
				g.updateMatrix();
				g.matrixAutoUpdate = false;
			}
			subGroups[i] = g;
		}

		// Compute parent relationships using child/sibling chains
		for (let i = 0; i < objects.length; i++) {
			const sub = objects[i];
			const firstChild = sub.child;
			if (firstChild >= 0 && firstChild < objects.length) {
				// first child belongs to i
				parentIndex[firstChild] = i;
				// all siblings of first child also belong to i
				let s = objects[firstChild].sibling;
				while (s >= 0 && s < objects.length) {
					parentIndex[s] = i;
					s = objects[s].sibling;
				}
			}
		}

		// Attach groups to parents or scene root, then add meshes and vhots
		AppState.vhotMarkers = []; 
		const vhotMaterial = new THREE.MeshBasicMaterial({ color: 0xff00ff });
		const vhotGeom = new THREE.SphereGeometry(0.05, 8, 8);
		for (let i = 0; i < objects.length; i++) {
			const sub = objects[i];
			const g = subGroups[i];

			// Attach to parent if exists, else to scene root
			const p = parentIndex[i];
			if (p >= 0) subGroups[p].add(g); else sceneRoot.add(g);

			// Mesh for this subobject (generated in toThree)
			if (sub._threeGeom) {
				let mesh;
				if (AppState.materials.length > 0) {
					mesh = new THREE.Mesh(sub._threeGeom, AppState.materials);
				} else {
					let material = new THREE.MeshLambertMaterial({ color: 0x6699cc, flatShading: true });
					mesh = new THREE.Mesh(sub._threeGeom, material);
				}
				g.add(mesh);
			}

			// Vhots in local space of subobject
			if (sub && sub.num_vhots > 0) {
				const first = sub.first_vhot || 0;
				const count = sub.num_vhots || 0;
				for (let vi = first; vi < first + count; vi++) {
					const vhot = AppState.model.vhots && AppState.model.vhots[vi];
					if (!vhot) continue;
					const marker = new THREE.Mesh(vhotGeom, vhotMaterial);
					marker.position.set(vhot.point[0], vhot.point[1], vhot.point[2]);
					g.add(marker);
					AppState.vhotMarkers.push(marker); // Store reference to vhot marker
				}
			}
		}
	}

	// Optional bounding box and vhot markers
	if (AppState.model && AppState.model.min_bounds && AppState.model.max_bounds) {
		const min = AppState.model.min_bounds;
		const max = AppState.model.max_bounds;
		const size = [
			max[0] - min[0],
			max[1] - min[1],
			max[2] - min[2]
		];
		const center = [
			(min[0] + max[0]) / 2,
			(min[1] + max[1]) / 2,
			(min[2] + max[2]) / 2
		];
		const boxGeom = new THREE.BoxGeometry(size[0], size[1], size[2]);
		const boxWire = new THREE.EdgesGeometry(boxGeom);
		const boxMat = new THREE.LineBasicMaterial({ color: 0xff0000 });
		AppState.boundingBox = new THREE.LineSegments(boxWire, boxMat);
		AppState.boundingBox.position.set(center[0], center[1], center[2]);

		// Add bbox under the same scene root so it shares global rotation
		const lastChild = AppState.threeScene.children[AppState.threeScene.children.length - 1];
		if (lastChild && lastChild.type === 'Group') {
			lastChild.add(AppState.boundingBox);
		} else {
			AppState.threeScene.add(AppState.boundingBox);
		}

		// Toggle bounding box visibility
		const bboxToggle = document.getElementById('toggle-bbox');
		if (bboxToggle) {
			bboxToggle.addEventListener('change', function() {
				if (AppState.boundingBox) {
					AppState.boundingBox.visible = bboxToggle.checked;
				}
			});
		}

		// Toggle vhot markers visibility
		const vhotToggle = document.getElementById('toggle-vhots');
		if (vhotToggle) {
			vhotToggle.addEventListener('change', function() {
				AppState.vhotMarkers.forEach(marker => {
					if (marker) marker.visible = vhotToggle.checked;
				});
			});
		}
	}

	

	// Ambient light 
	let ambient = new THREE.AmbientLight(0xffffff, 1.0);
	AppState.threeScene.add(ambient);

	// Renderer
	AppState.threeRenderer = new THREE.WebGLRenderer({ antialias: true });
	AppState.threeRenderer.setSize(width, height);
	AppState.threeRenderer.domElement.style.width = "100%";
	AppState.threeRenderer.domElement.style.height = "100%";
	AppState.threeRenderer.domElement.style.display = "block";

	// Insert canvas into viewer
	if (viewer) {
		viewer.innerHTML = "";
		viewer.appendChild(AppState.threeRenderer.domElement);
	} else {
		document.body.appendChild(AppState.threeRenderer.domElement);
	}

    let controls = new OrbitControls(AppState.threeCamera, AppState.threeRenderer.domElement);

	animateThree();
}

function animateThree() {
    requestAnimationFrame(animateThree);
    AppState.threeRenderer.render(AppState.threeScene, AppState.threeCamera);
}


////////// BIN STUFF ///////////
const SZ_R64 = 8;
const SZ_R32 = 4;
const SZ_I32 = 4;
const SZ_U32 = 4;
const SZ_I16 = 2;
const SZ_U16 = 2;
const SZ_I8 = 1;
const SZ_U8 = 1;
class Buffer {
	buf; // ArrayBuffer
	dv;  // DataView
	cursor;
	
	constructor(buffer) {
		this.buf = buffer;
		this.dv = new DataView(this.buf);
		this.cursor = 0;
	}
	
	r64(at) {
		if(!at)
			at = this.cursor;
		this.cursor += SZ_R64;	
		return this.dv.getFloat64(at, true);
	}
	
	r32(at) {
		if(!at) at = this.cursor;
		this.cursor += SZ_R32;
		return this.dv.getFloat32(at, true);
	}
	
	set_r32(val, at) {
		if(!at) at = this.cursor;
		this.cursor += SZ_R32;
		this.dv.setFloat32(at, val, true);
	}
	
	i32(at) {
		if(!at) at = this.cursor;
		this.cursor += SZ_I32;;
		return this.dv.getInt32(at, true);
	}
	
	u32(at) {
		if(!at) at = this.cursor;
		this.cursor += SZ_U32;
		return this.dv.getUint32(at, true);
	}

	set_u32(val, at) { 
		if(!at) at = this.cursor;
		this.cursor += SZ_U32;
		this.dv.setUint32(at, val, true);
	}
	
	i16(at) {
		if(!at) at = this.cursor;
		this.cursor += SZ_I16;
		return this.dv.getInt16(at, true);
	}
	
	set_i16(val, at) {
		if(!at) at = this.cursor;
		this.cursor += SZ_I16;
		this.dv.setInt16(at, val, true);
	}
	
	u16(at) {
		if(!at) at = this.cursor;
		this.cursor += SZ_U16;
		return this.dv.getUint16(at, true);
	}
	
	set_u16(val, at) {
		if(!at) at = this.cursor;
		this.cursor += SZ_U16;
		this.dv.setUint16(at, val, true);
	}
	
	i8(at) {
		if(!at) at = this.cursor;
		this.cursor += SZ_I8;
		return this.dv.getInt8(at, true);
	}

	set_i8(val, at) {
		if(!at) at = this.cursor;
		this.cursor += SZ_U8;
		this.dv.setInt8(at, val, true);
	}
	
	u8(at) {
		if(!at) at = this.cursor;
		this.cursor += SZ_U8;
		return this.dv.getUint8(at, true);
	}
	
	set_u8(val, at) {
		if(!at) at = this.cursor;
		this.cursor += SZ_U8;
		this.dv.setUint8(at, val, true);
	}
	
	vec3f(at) {
		if(!at) at = this.cursor;
		let x = this.r32();
		let y = this.r32();
		let z = this.r32();
		return [x,y,z];
	}
	
	str(at, until = 0) {
		if(!until) {
			until = at;
			at = this.cursor;
		}
		let acc = "";
		let arr = new Uint8Array(this.buf, at, until);
		for(let i = 0; i < arr.length; i++) {
			if(arr[i]) acc += String.fromCharCode(arr[i]);
			else break; // null character
		}
		this.cursor += until;
		return acc;
	}
	
	set_str(val, size) {
		let min = size > val.length ? val.length : size;
		for(let c of val) {
			if(c) this.set_u8(c.charCodeAt(0));
		}
		this.cursor += size - val.length;
	}
	
}

class vec3 {
	x; y; z;
	constructor(x,y,z) {
		if(!x) {
			this.x = 0; this.y = 0; this.z = 0;
		} else if(!y) {
			this.x = x[0]; this.y = x[1]; this.z = x[2];
		} else {
			this.x = x; this.y = y; this.z = z;
		}
	}
}

class Model {

	/***** HEADER *****/
					// size, byte offset (based off Telliamed's lgmd.h)
	signature; 		// u32, 0
	version;		// u32, 4
	name; 			// u8[8], 8
	
	max_radius; 	// float32, 16
	min_radius; 	// float32, 20
	max_bounds; 	// 3xfloat32, 24
	min_bounds; 	// 3xfloat32, 36
	center; 		// 3xfloat32, 48
	
	num_polys; 		// u16, 60
	num_points; 	// u16, 62
	num_params;		// u16, 64
	num_materials; 	// u8, 66
	num_vcalls; 	// u8, 67
	num_vhots; 		// u8, 68
	num_objs; 		// u8, 69
	
	offset_obj;		// u32, 70
	offset_material;// u32, 74
	offset_mapping;	// u32, 78
	offset_vhot;	// u32, 82
	offset_point;	// u32, 86
	offset_light;	// u32, 90
	offset_normal;	// u32, 94
	offset_poly;	// u32, 96
	offset_node;	// u32, 102
	
	bin_size; 		// u32, 106
	
	// version 4 only:
		material_ex_flags;	// u32, 110
		material_ex_offset; // u32, 114
		material_ex_size;  	// u32, 118
		
	// END OF HEADER PROPER
	
	num_uvmaps; 	// calculated int
	num_lights;		// calculated int 
	num_normals; 	// calculated int
	
	
	
	points; 		// Float32Array, arranged [x,y,z, x,y,z, ...]
	lights;
	normals;
	uvs;

	polys;
	materials; 		
	
	show_stats() {
		let table = document.getElementById("table");
		if (!table) return;
		// Clear table and add model header
		table.innerHTML = "";
		let headerRow = document.createElement("tr");
		headerRow.innerHTML = `<th colspan=2 id="name" style="height: 18pt;">MODEL HEADER</th>`;
		table.appendChild(headerRow);

		function addRow(label, value, type="") {
			let r = document.createElement("tr");
			let v = value;
			if(type == "vec3") {
				v = value ? value.map(x => Number.parseFloat(x).toFixed(2)).join(", ") : "";
			} else if(type == "hex") {
				v = "0x" + value.toString(16).toUpperCase();
			}
			r.innerHTML = `<td>${label}</td><td>${v}</td>`;
			table.appendChild(r);
		}

		addRow("version", this.version);
		addRow("name", this.name);
		addRow("max radius", this.max_radius);
		addRow("min radius", this.min_radius);
		addRow("max bounds", this.max_bounds, "vec3");
		addRow("min bounds", this.min_bounds, "vec3");
		addRow("# polys", this.num_polys); // TODO get a list of n-gons
		addRow("# points", this.num_points);
		addRow("# params", this.num_params);
		addRow("# materials", this.num_materials);
		addRow("# vcalls", this.num_vcalls);
		addRow("# vhots", this.num_vhots);
		addRow("# objects", this.num_objs);
		addRow("obj offset", this.offset_obj, "hex");
		addRow("material offset", this.offset_material, "hex");
		addRow("UVs offset", this.offset_mapping, "hex");
		addRow("vhot offset", this.offset_vhot, "hex");
		addRow("point offset", this.offset_point, "hex");
		addRow("light offset", this.offset_light, "hex");
		addRow("normal offset", this.offset_normal, "hex");
		addRow("poly offset", this.offset_poly, "hex");
		addRow("node offset", this.offset_node, "hex");
		addRow("bin size", this.bin_size);
	}
}

const OBJECT_HEADER_SIZE = 93;
class Obj {
	name; 		// u8[8]
	transform; 	// 61 bytes, see Transform class 
	child;		// i16
	sibling; 	// i16
	
	// 0-based indices into their lists
	first_vhot;		// u16 
	num_vhots;  	// u16
	first_point;	// u16
	num_points; 	// u16
	first_light;	// u16
	num_lights; 	// u16
	first_normal;	// u16
	num_normals; 	// u16
	
	// byte offset into its list 
	first_node; 	// u16
	num_nodes; 		// u16

	show_stats(index = 0) {
		let table = document.getElementById("table");
		let row = document.createElement("tr");
		row.innerHTML = `<th colspan="2">OBJECT #${index}</th>`;
		table.appendChild(row);

		function addRow(label, value) {
			let r = document.createElement("tr");
			r.innerHTML = `<td>${label}</td><td>${value}</td>`;
			table.appendChild(r);
		}

		addRow("name", this.name);
		addRow("child", this.child);
		addRow("sibling", this.sibling);
		addRow("first_vhot", this.first_vhot);
		addRow("num_vhots", this.num_vhots);
		addRow("first_point", this.first_point);
		addRow("num_points", this.num_points);
		addRow("first_light", this.first_light);
		addRow("num_lights", this.num_lights);
		addRow("first_normal", this.first_normal);
		addRow("num_normals", this.num_normals);
		addRow("first_node", this.first_node);
		addRow("num_nodes", this.num_nodes);

		if (this.transform) {
			addRow("transform.type", this.transform.type);
			addRow("transform.id", this.transform.id);
			addRow("transform.min_position", this.transform.min_position);
			addRow("transform.max_position", this.transform.max_position);
			addRow("transform.axis[0]", this.transform.axis[0]);
			addRow("transform.axis[1]", this.transform.axis[1]);
			addRow("transform.axis[2]", this.transform.axis[2]);
			addRow("transform.center", this.transform.center);
		}
	}
}

const MATERIAL_TYPE_TEXTURE = 0;
const MATERIAL_TYPE_COLOR = 1;

const MATERIAL_HEADER_SIZE = 26;
class Material {
	name;	// char[16]
	type; 	// u8, 0 = tex, 1 = rgb
	id; 	// i8
	
	// rgba - u8 each
	blue;
	green;
	red; 	
	// *u8 pad here*
	pal_index;	// u32
	
	// tex
	handle; 	// u32
	uvscale; 	// r32

	// MaterialEX:
	has_trans;
	has_illum;
	trans; 
	illum; 

	show_stats(index = 0, version = 4) {
		let table = document.getElementById("table");
		let row = document.createElement("tr");
		row.innerHTML = `<th colspan="2">MATERIAL #${index}</th>`;
		table.appendChild(row);

		function addRow(label, value) {
			let r = document.createElement("tr");
			r.innerHTML = `<td>${label}</td><td>${value}</td>`;
			table.appendChild(r);
		}

		addRow("name", this.name);
		addRow("type", this.type == 1 ? "RGB" : "Texture");
		addRow("id", this.id);

		if (this.type == 1) {
			addRow("red", this.red);
			addRow("green", this.green);
			addRow("blue", this.blue);
			addRow("pal_index", this.pal_index);
		} else {
			addRow("handle", this.handle);
			addRow("uvscale", this.uvscale);
		}

		if (version == 4) {
			addRow("trans", this.trans !== undefined ? this.trans : "");
			addRow("illum", this.illum !== undefined ? this.illum : "");
		}
	}
}

const MATERIAL_EX_HEADER_SIZE = 16;
class MaterialEx {
	trans; // r32
	illum; // r32
	unknown1; // something32
	unknown2; // something32 (these two together seem like a sane double, though not all the time)

	build() {
		let buf = new Buffer(new ArrayBuffer(MATERIAL_EX_HEADER_SIZE));
		buf.set_r32(0);
		buf.set_r32(0);
		buf.set_r32(0);
		buf.set_r32(0);
		return buf;
	}
}

const LIGHT_HEADER_SIZE = 8;
class Light {
	object; 	//u16
	point; 		//u16
	unknown; 	//u32 - seems like this is either for SW dromed rendering (see rendobj.cpp:380),
}				//		or is used and updated internally during runtime

const VHOT_HEADER_SIZE = 16;
class Vhot {
	id; // i16
	point; // vec3f
}

const POLY_TYPE_TEXTURE = 0x1B;
const POLY_TYPE_RGB = 0x59;
const POLY_TYPE_PAL = 0x39;

const POLY_HEAD_SIZE = 12;
class Polygon {
	/* BEGIN HEADER */
	id; 		// i16
	material; 	// i16
	type; 		// u8
	num_points; // u8
	normal; 	// u16, index into normal list
	plane; 		// r32, length from center to poly surface (presumably the center?)
	
	points; 	// u16[], index into point list
	lights; 	// u16[], index into lights list
	uvs; 		// u16[], index into uv list IF type = 0x1B
	mat_ix; 	// u8, version 4 only, 0-based index into materials
	/* END HEADER */
	
	points;
	lights;
	uvs;

	constructor() {
		this.points = [];
		this.lights = [];
		this.uvs = [];
	}
}



const TRANSFORM_HEADER_SIZE = 61;
class Transform {
	type;			// u8
	id; 			// i32
	min_position; 	// r32
	max_position;	// r32
	axis;			// vec3f[3]
	center;			// vec3f
}

const BSP_NODE_RAW = 0;
const BSP_NODE_SPLIT = 1;
const BSP_NODE_CALL = 2;
const BSP_NODE_HEADER = 4;

const BSP_NODE_SIZE = 31;
class BspRawNode {
	type = BSP_NODE_RAW;
	
	bounds_center; 	// vec3f
	bounds_radius; 	// r32
	num_polys; 		// u16
	polys;			// u16[]
}

class BspSplitNode {
	type = BSP_NODE_SPLIT;

	bounds_center; 	// vec3f
	bounds_radius; 	// r32
	num_polys_back;	// u16
	normal; 		// u16
	plane; 			// r32
	back_node; 		// i16
	front_node; 	// i16
	num_polys_front;// u16
	
	back_polys; 	// u16[]
	front_polys; 	// u16[]
	
}

class BspCallNode {
	type = BSP_NODE_CALL;
	
	bounds_center; 	// vec3f
	bounds_radius; 	// r32
	num_polys_back;	// u16
	call_node; 		// s16
	num_polys_front;// u16
	
	back_polys; 	// u16[]
	front_polys; 	// u16[]
}

class BspHeaderNode {
	type = BSP_NODE_HEADER;
	
	object;	// u16
}


let inp = document.getElementById("input");
inp.addEventListener("change", open_file);

function open_file() {
	let f = inp.files[0]; 
	let extension = f.name.split(".").slice(-1);
	let loader = 0;
	if (extension == "bin") loader = read_bin;
	// Clear and reload the table
	let table = document.getElementById("table");
	if (table) {
		// Remove all rows except the header
		while (table.rows.length > 1) {
			table.deleteRow(1);
		}
	}
	let reader = new FileReader();
	reader.readAsArrayBuffer(f);
	reader.addEventListener("loadend", () => {
		let bin = reader.result;
		read_bin(bin);
	});
	
}

function read_bin(bin) {
	let buffer = new Buffer(bin);
	let signature = buffer.u32();
	if(signature != 0x444D474C) {
		console.log("incorrect signature. Bye.");
		return;
	}
	
	let model = new Model();
	
	model.version 		= buffer.u32();
	model.name 			= buffer.str(8);
	model.max_radius 	= buffer.r32();	
	model.min_radius 	= buffer.r32();

	model.max_bounds 	= buffer.vec3f();
	model.min_bounds 	= buffer.vec3f();
	model.center 	 	= buffer.vec3f();
	
	model.num_polys 	= buffer.u16();
	model.num_points 	= buffer.u16();
	model.num_params 	= buffer.u16();
	model.num_materials = buffer.u8();
	model.num_vcalls 	= buffer.u8();
	model.num_vhots	 	= buffer.u8();
	model.num_objs 		= buffer.u8();
	
	model.offset_obj 		= buffer.u32();
	model.offset_material 	= buffer.u32();
	model.offset_mapping 	= buffer.u32();
	model.offset_vhot		= buffer.u32();
	model.offset_point 		= buffer.u32();
	model.offset_light 		= buffer.u32();
	model.offset_normal 	= buffer.u32();
	model.offset_poly 		= buffer.u32();
	model.offset_node 		= buffer.u32();
	
	model.bin_size 	= buffer.u32(); 
	
	if(model.version == 4) {
		model.material_ex_flags	= buffer.u32();
		model.material_ex_offset= buffer.u32();
		model.material_ex_size 	= buffer.u32();
		model.uses_trans = model.material_ex_flags & 1;
		model.uses_illum = model.material_ex_flags & 2;
	}
	
	model.num_uvmaps = (model.offset_vhot - model.offset_mapping) / 8;
	model.num_lights = (model.offset_normal - model.offset_light) / 8;
	model.num_normals = (model.offset_poly - model.offset_normal) / 12;
	
	// points
	let points = bin.slice(model.offset_point, model.offset_point + (model.num_points * 12));
	model.points = new Float32Array(points);
	
	// normals
	let normals = bin.slice(model.offset_normal, model.offset_normal + (model.num_normals * 12));
	model.normals = new Float32Array(normals);
	
	// uvmaps
	if(model.num_uvmaps > 0) {
		let uvmaps = bin.slice(model.offset_mapping, model.offset_mapping + (model.num_uvmaps * 8));
		model.uvmaps = new Float32Array(uvmaps);
	}
	
	// lights
	model.lights = [];
	if(model.num_lights > 0) {
		
		let lights = bin.slice(model.offset_light, model.offset_light + (model.num_lights * 8));
		let lbuffer = new Buffer(lights);
		
		for(let i = 0; i < model.num_lights; i++) {
			let light = new Light();
			
			light.object  = lbuffer.u16();
			light.point   = lbuffer.u16();
			light.unknown = lbuffer.u32();
			
			model.lights.push(light);
		}	
	}
	
	// vhots
	model.vhots = [];
	if(model.num_vhots > 0) {
	
		let vhots = bin.slice(model.offset_vhot, model.offset_vhot + (VHOT_HEADER_SIZE * model.num_vhots));
		let vbuffer = new Buffer(vhots);
		
		for(let i = 0; i < model.num_vhots; i++) {
			let vhot = new Vhot();
			
			vhot.id 	= vbuffer.i32();
			vhot.point  = vbuffer.vec3f();
			
			model.vhots.push(vhot);
		}
	}
	
	// materials
	model.materials = []; 
	let materials = bin.slice(model.offset_material, model.offset_material + (MATERIAL_HEADER_SIZE * model.num_materials));
	let mbuffer = new Buffer(materials);

	for(let i = 0; i < model.num_materials; i++) {		
		let material = new Material();
		
		material.name 	= mbuffer.str(16);
		material.type 	= mbuffer.u8();
		material.id 	= mbuffer.i8();
		
		if(material.type == 1) { // it's RGB
			material.blue 		= mbuffer.u8();
			material.green 		= mbuffer.u8();
			material.red 		= mbuffer.u8();
								  mbuffer.u8(); // pad 
			material.pal_index 	= mbuffer.u32();
		} else { // it's a texture
			material.handle 	= mbuffer.u32();
			material.uvscale 	= mbuffer.r32();
		}	
		
		model.materials.push(material);		
	}

	console.log(model)
	// aux material
	// optimistic assumption: the number of aux materials = number of real materials
	if(model.version == 4 && model.material_ex_offset) {
		let aux = bin.slice(model.material_ex_offset, model.material_ex_offset + (model.material_ex_size * model.num_materials));
		let abuffer = new Buffer(aux)
		for(let i = 0; i < model.num_materials; i++) {
			model.materials[i].trans = abuffer.r32();
			model.materials[i].illum = abuffer.r32();
			if(model.material_ex_size > 8) { // sure enough, material_ex_size's warning against assuming struct size is correct
				abuffer.r32();abuffer.r32(); // MaxUV texel crap
			}
		}
	}
	
	// polygons
	const POLY_TYPE_TEXTURE = 0x1B;
	
	model.polys = [];
	
	let offset_polys = [];
	
	buffer.cursor = model.offset_poly;
	for(let i = 0; i < model.num_polys; i++) {
		offset_polys.push(buffer.cursor - model.offset_poly);
		let poly = new Polygon();
		
		poly.id = buffer.i16();
		poly.material = buffer.i16();
		poly.type = buffer.u8();
		poly.num_points = buffer.u8();
		poly.normal = buffer.u16();
		poly.plane = buffer.r32();
		
		poly.points = [];
		for(let i = 0; i < poly.num_points; i++) {
			poly.points.push(buffer.u16());
		}
		
		poly.lights = [];
		for(let i = 0; i < poly.num_points; i++) {
			poly.lights.push(buffer.u16());
		}
		
		if(poly.type == POLY_TYPE_TEXTURE) {
			poly.uvs = [];
			for(let i = 0 ; i < poly.num_points; i++) {
				poly.uvs.push(buffer.u16());
			}
		}
		
		if(model.version == 4) 
			poly.mat_ix = buffer.u8();

		model.polys.push(poly);
		
	}
	
	// objects
	let objs = bin.slice(model.offset_obj, model.offset_obj + (OBJECT_HEADER_SIZE * model.num_objs));
	let obuffer = new Buffer(objs);
	
	model.objects = [];
	model.num_nodes = 0;
	
	let asdf = 0;
	for(let i = 0; i < model.num_objs; i++) {
		let obj = new Obj();
		obj.name = obuffer.str(8);
		
		// transform 
		obj.transform = new Transform();
		obj.transform.type = obuffer.u8();
		obj.transform.id = obuffer.i32();
		obj.transform.min_position = obuffer.r32();
		obj.transform.max_position = obuffer.r32();
		obj.transform.axis = [];
		obj.transform.axis.push(obuffer.vec3f());
		obj.transform.axis.push(obuffer.vec3f());
		obj.transform.axis.push(obuffer.vec3f());
		obj.transform.center = obuffer.vec3f();
		
		obj.child = obuffer.i16();
		obj.sibling = obuffer.i16();
		
		obj.first_vhot = obuffer.u16();
		obj.num_vhots = obuffer.u16();
		obj.first_point = obuffer.u16();
		obj.num_points = obuffer.u16();
		obj.first_light = obuffer.u16();
		obj.num_lights = obuffer.u16();
		obj.first_normal = obuffer.u16();
		obj.num_normals = obuffer.u16();
		
		obj.first_node = obuffer.u16();
		asdf = model.offset_obj + obuffer.cursor;
		obj.num_nodes = obuffer.u16();
		model.num_nodes += obj.num_nodes;

		// because we iterate over the objects' polygons later, we need reference to them within the object
		// we have to go through each polygon and see if any of its points are within the object's point range
		obj.polys = [];
		let p_start = obj.first_point;
		let p_end = p_start + obj.num_points;
		for(let p = 0; p < model.polys.length; p++) {
			let poly = model.polys[p];
			for(let pi = 0; pi < poly.points.length; pi++) {
				let point_index = poly.points[pi];
				if(point_index >= p_start && point_index < p_end) {
					obj.polys.push(poly);
					break; 
				}
			}
		}
		
		model.objects.push(obj);
	}
	
	// NOTE we don't care about BSP tree at all here
	
	model.show_stats();
	for(let i = 0; i < model.objects.length; i++) {
		model.objects[i].show_stats(i);
	}
	for(let i = 0; i < model.materials.length; i++) {
		model.materials[i].show_stats(i, model.version);
	}
	// Store model in AppState
	AppState.model = model;
	// Display geometry in Three.js
	let geometries = toThree(model);
	setupThree(geometries);
	return model;
}

// from our model, massage the data into BufferGeometry for three.js
function toThree(model) {
	let geometries = [];

    // Build material index mapping (Three expects 0-based indices)
    let materialMap = {};
    for (let i = 0; i < model.materials.length; i++) {
        materialMap[i] = i;
    }

	for (let sub of model.objects) {
		let positions = [];
		let uvs = [];
		let normals = [];
		let groups = [];
		let vertexCount = 0;
		
		// store the subobject transform matrix
		let sub_transform_matrix = null;
		if (sub.transform && sub.transform.type !== 0) {
			sub_transform_matrix = new THREE.Matrix4();
			sub_transform_matrix.set(
				sub.transform.axis[0][0], sub.transform.axis[1][0], sub.transform.axis[2][0], sub.transform.center[0],
				sub.transform.axis[0][1], sub.transform.axis[1][1], sub.transform.axis[2][1], sub.transform.center[1],
				sub.transform.axis[0][2], sub.transform.axis[1][2], sub.transform.axis[2][2], sub.transform.center[2],
				0, 0, 0, 1
			);
		}
		sub.sub_transform_matrix = sub_transform_matrix;

		// create a new geometry for this subobject
		let geom = new THREE.BufferGeometry();
		for (let poly of sub.polys) {
			if (poly.type != POLY_TYPE_TEXTURE) continue;

			let startVertex = vertexCount;
			let matIndex = poly.mat_ix !== undefined ? poly.mat_ix : (poly.material - 1);

			if (poly.num_points > 3) { // we need to triangulate
				for (let i = 1; i < poly.num_points - 1; i++) {
					const tri_indices = [0, i + 1, i];
					for (let j = 0; j < 3; j++) {
						let idx = tri_indices[j];
						let p_ix = poly.points[idx] * 3;
						positions.push(model.points[p_ix]);
						positions.push(model.points[p_ix + 1]);
						positions.push(model.points[p_ix + 2]);

						let uv_ix = poly.uvs[idx] * 2;
						uvs.push(model.uvmaps[uv_ix]);
						uvs.push(1.0 - model.uvmaps[uv_ix + 1]);

						let n_ix = poly.normal * 3;
						normals.push(model.normals[n_ix]);
						normals.push(model.normals[n_ix + 1]);
						normals.push(model.normals[n_ix + 2]);
					}
					groups.push({
						start: vertexCount,
						count: 3,
						materialIndex: materialMap[matIndex]
					});
					vertexCount += 3;
				}
			} else {
				for (let i = 0; i < poly.num_points; i++) {
					let idx = poly.num_points - 1 - i;
					let p_ix = poly.points[idx] * 3;
					positions.push(model.points[p_ix]);
					positions.push(model.points[p_ix + 1]);
					positions.push(model.points[p_ix + 2]);

					let uv_ix = poly.uvs[idx] * 2;
					uvs.push(model.uvmaps[uv_ix]);
					uvs.push(1.0 - model.uvmaps[uv_ix + 1]);

					let n_ix = poly.normal * 3;
					normals.push(model.normals[n_ix]);
					normals.push(model.normals[n_ix + 1]);
					normals.push(model.normals[n_ix + 2]);
				}
				groups.push({
					start: vertexCount,
					count: poly.num_points,
					materialIndex: materialMap[matIndex]
				});
				vertexCount += poly.num_points;
			}
		}

		if (positions.length > 0) {
			geom.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
			geom.setAttribute('normal', new THREE.Float32BufferAttribute(normals, 3));
			geom.setAttribute('uv', new THREE.Float32BufferAttribute(uvs, 2));

			// Assign groups for multi-materials
			for (let g of groups) {
				geom.addGroup(g.start, g.count, g.materialIndex);
			}

			geom.computeBoundingSphere();
			// Store geometry on subobject so setupThree can work with it
			sub._threeGeom = geom;
			geometries.push(geom);
		}
	}

    return geometries;
}

// Initialize the application when the page loads
document.addEventListener('DOMContentLoaded', initializeApp);

</script>
</body>
</html>
